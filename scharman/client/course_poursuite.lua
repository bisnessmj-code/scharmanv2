-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
-- â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘
-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘
-- â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
-- â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•
-- CLIENT - MODE COURSE POURSUITE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- VARIABLES LOCALES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local inGame = false
local currentVehicle = nil
local instanceId = nil
local blockExitThread = nil
local zoneCheckThread = nil
local gameEndTime = nil
local botPed = nil
local botVehicle = nil

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FONCTIONS UTILITAIRES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Afficher une notification NUI personnalisÃ©e
local function ShowGameNotification(message, duration, notifType)
    SendNUIMessage({
        action = 'showNotification',
        data = {
            message = message,
            duration = duration or Config.CoursePoursuit.MessageDuration,
            type = notifType or 'info'
        }
    })
end

-- Charger un modÃ¨le
local function LoadModel(model)
    local modelHash = GetHashKey(model)
    
    if not IsModelValid(modelHash) then
        Config.ErrorPrint('ModÃ¨le invalide: ' .. model)
        return false
    end
    
    RequestModel(modelHash)
    
    local timeout = 0
    while not HasModelLoaded(modelHash) do
        Wait(100)
        timeout = timeout + 100
        
        if timeout >= 10000 then
            Config.ErrorPrint('Timeout lors du chargement du modÃ¨le: ' .. model)
            return false
        end
    end
    
    Config.DebugPrint('ModÃ¨le chargÃ©: ' .. model)
    return true
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FONCTIONS BOT ADVERSAIRE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Supprimer le bot
local function DeleteBot()
    if DoesEntityExist(botVehicle) then
        DeleteEntity(botVehicle)
        botVehicle = nil
        Config.DebugPrint('VÃ©hicule bot supprimÃ©')
    end
    
    if DoesEntityExist(botPed) then
        DeleteEntity(botPed)
        botPed = nil
        Config.DebugPrint('Bot supprimÃ©')
    end
end

-- Spawner un bot adversaire
local function SpawnBotAdversary()
    if not Config.CoursePoursuit.SpawnBotInSolo then
        Config.DebugPrint('Spawn bot dÃ©sactivÃ© dans la config')
        return
    end
    
    Config.InfoPrint('Spawn du bot adversaire...')
    
    local ped = PlayerPedId()
    local playerCoords = GetEntityCoords(ped)
    local playerHeading = GetEntityHeading(ped)
    
    -- Calculer la position du bot (Ã  cÃ´tÃ© du joueur)
    local offset = Config.CoursePoursuit.BotSpawnOffset
    local forwardX = math.cos(math.rad(playerHeading))
    local forwardY = math.sin(math.rad(playerHeading))
    
    local botCoords = vector3(
        playerCoords.x + (forwardX * offset.x) + offset.y,
        playerCoords.y + (forwardY * offset.x),
        playerCoords.z + offset.z
    )
    
    -- Charger le modÃ¨le du bot
    if not LoadModel(Config.CoursePoursuit.BotModel) then
        Config.ErrorPrint('Ã‰chec chargement modÃ¨le bot')
        return
    end
    
    -- CrÃ©er le bot
    botPed = CreatePed(4, GetHashKey(Config.CoursePoursuit.BotModel), botCoords.x, botCoords.y, botCoords.z, playerHeading, true, false)
    
    if not DoesEntityExist(botPed) then
        Config.ErrorPrint('Ã‰chec crÃ©ation bot')
        return
    end
    
    Config.DebugPrint('Bot crÃ©Ã©: ' .. botPed)
    
    -- Rendre le bot invincible
    SetEntityInvincible(botPed, true)
    SetBlockingOfNonTemporaryEvents(botPed, true)
    
    -- Charger le modÃ¨le du vÃ©hicule bot
    if not LoadModel(Config.CoursePoursuit.BotVehicle) then
        Config.ErrorPrint('Ã‰chec chargement vÃ©hicule bot')
        DeleteEntity(botPed)
        botPed = nil
        return
    end
    
    -- CrÃ©er le vÃ©hicule du bot
    botVehicle = CreateVehicle(
        GetHashKey(Config.CoursePoursuit.BotVehicle),
        botCoords.x,
        botCoords.y,
        botCoords.z,
        playerHeading,
        true,
        false
    )
    
    if not DoesEntityExist(botVehicle) then
        Config.ErrorPrint('Ã‰chec crÃ©ation vÃ©hicule bot')
        DeleteEntity(botPed)
        botPed = nil
        return
    end
    
    Config.DebugPrint('VÃ©hicule bot crÃ©Ã©: ' .. botVehicle)
    
    -- Personnaliser le vÃ©hicule bot
    local botColor = Config.CoursePoursuit.BotVehicleColor
    SetVehicleCustomPrimaryColour(botVehicle, botColor.primary.r, botColor.primary.g, botColor.primary.b)
    SetVehicleCustomSecondaryColour(botVehicle, botColor.secondary.r, botColor.secondary.g, botColor.secondary.b)
    SetVehicleNumberPlateText(botVehicle, 'BOT~AI')
    
    -- Rendre le vÃ©hicule plus rÃ©sistant
    SetVehicleEngineHealth(botVehicle, 1000.0)
    SetVehicleBodyHealth(botVehicle, 1000.0)
    
    -- Attendre que le vÃ©hicule soit bien chargÃ©
    Wait(500)
    
    -- Mettre le bot dans le vÃ©hicule
    TaskWarpPedIntoVehicle(botPed, botVehicle, -1)
    
    -- Attendre que le bot soit dans le vÃ©hicule
    Wait(1000)
    
    -- Faire conduire le bot
    if Config.CoursePoursuit.BotRandomRoute then
        TaskVehicleDriveWander(
            botPed,
            botVehicle,
            Config.CoursePoursuit.BotSpeed,
            Config.CoursePoursuit.BotDrivingStyle
        )
        Config.DebugPrint('Bot en conduite alÃ©atoire')
    else
        -- Conduire vers un point lointain
        local targetCoords = vector3(
            botCoords.x + 500.0,
            botCoords.y + 500.0,
            botCoords.z
        )
        TaskVehicleDriveToCoordLongrange(
            botPed,
            botVehicle,
            targetCoords.x,
            targetCoords.y,
            targetCoords.z,
            Config.CoursePoursuit.BotSpeed,
            Config.CoursePoursuit.BotDrivingStyle,
            10.0
        )
        Config.DebugPrint('Bot en conduite vers point prÃ©cis')
    end
    
    -- LibÃ©rer les modÃ¨les
    SetModelAsNoLongerNeeded(GetHashKey(Config.CoursePoursuit.BotModel))
    SetModelAsNoLongerNeeded(GetHashKey(Config.CoursePoursuit.BotVehicle))
    
    Config.SuccessPrint('Bot adversaire spawnÃ© et en conduite!')
    ShowGameNotification('ðŸ¤– Un adversaire bot est apparu !', 4000, 'success')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DÃ‰MARRAGE DU JEU
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- DÃ©marrer le jeu
local function StartCoursePoursuiteGame(data)
    if inGame then
        Config.DebugPrint('DÃ©jÃ  en jeu')
        return
    end
    
    -- Protection contre Ã©cran noir avec pcall
    local success, err = pcall(function()
        Config.InfoPrint('DÃ©marrage de la Course Poursuite...')
        
        local ped = PlayerPedId()
        instanceId = data.instanceId
        
        -- RÃ©cupÃ©rer les coordonnÃ©es et le modÃ¨le
        local spawnCoords = data.spawnCoords or Config.CoursePoursuit.SpawnCoords
        local vehicleModel = data.vehicleModel or Config.CoursePoursuit.VehicleModel
        
        -- Notification de tÃ©lÃ©portation
        ShowGameNotification(Config.CoursePoursuit.Notifications.teleporting, 2000, 'info')
        
        -- Fade out
        DoScreenFadeOut(800)
        while not IsScreenFadedOut() do
            Wait(10)
        end
        
        -- TÃ©lÃ©porter le joueur
        SetEntityCoords(ped, spawnCoords.x, spawnCoords.y, spawnCoords.z, false, false, false, true)
        SetEntityHeading(ped, spawnCoords.w)
        
        -- Attendre stabilisation
        Wait(500)
        
        -- Charger le modÃ¨le du vÃ©hicule
        if not LoadModel(vehicleModel) then
            error('Ã‰chec du chargement du modÃ¨le de vÃ©hicule')
        end
        
        -- CrÃ©er le vÃ©hicule
        currentVehicle = CreateVehicle(
            GetHashKey(vehicleModel),
            spawnCoords.x,
            spawnCoords.y,
            spawnCoords.z,
            spawnCoords.w,
            true,
            false
        )
        
        if not DoesEntityExist(currentVehicle) then
            error('Ã‰chec de la crÃ©ation du vÃ©hicule')
        end
        
        Config.DebugPrint('VÃ©hicule crÃ©Ã©: ' .. currentVehicle)
        
        -- Personnaliser le vÃ©hicule
        local primaryColor = Config.CoursePoursuit.VehicleCustomization.primaryColor
        local secondaryColor = Config.CoursePoursuit.VehicleCustomization.secondaryColor
        SetVehicleCustomPrimaryColour(currentVehicle, primaryColor.r, primaryColor.g, primaryColor.b)
        SetVehicleCustomSecondaryColour(currentVehicle, secondaryColor.r, secondaryColor.g, secondaryColor.b)
        
        -- Appliquer les mods
        local mods = Config.CoursePoursuit.VehicleCustomization.mods
        SetVehicleMod(currentVehicle, 11, mods.engine, false)
        SetVehicleMod(currentVehicle, 12, mods.brakes, false)
        SetVehicleMod(currentVehicle, 13, mods.transmission, false)
        SetVehicleMod(currentVehicle, 15, mods.suspension, false)
        ToggleVehicleMod(currentVehicle, 18, mods.turbo)
        
        -- Plaque d'immatriculation
        SetVehicleNumberPlateText(currentVehicle, 'COURSE')
        
        -- Remplir essence
        SetVehicleFuelLevel(currentVehicle, 100.0)
        
        -- SantÃ© du vÃ©hicule
        SetVehicleEngineHealth(currentVehicle, 1000.0)
        SetVehicleBodyHealth(currentVehicle, 1000.0)
        
        -- Verrouiller les portes pour empÃªcher les autres joueurs d'entrer
        SetVehicleDoorsLocked(currentVehicle, 2)
        SetVehicleDoorsLockedForAllPlayers(currentVehicle, true)
        
        -- Attendre que le vÃ©hicule soit bien crÃ©Ã©
        Wait(500)
        
        -- Mettre le joueur dans le vÃ©hicule (siÃ¨ge conducteur)
        TaskWarpPedIntoVehicle(ped, currentVehicle, -1)
        Config.DebugPrint('Joueur placÃ© dans le vÃ©hicule')
        
        -- Attendre que le joueur soit dans le vÃ©hicule
        Wait(1000)
        
        -- VÃ©rifier que le joueur est bien dans le vÃ©hicule
        if GetVehiclePedIsIn(ped, false) ~= currentVehicle then
            Config.ErrorPrint('Le joueur n\'est pas dans le vÃ©hicule!')
            -- RÃ©essayer
            TaskWarpPedIntoVehicle(ped, currentVehicle, -1)
            Wait(500)
        end
        
        -- LibÃ©rer le modÃ¨le
        SetModelAsNoLongerNeeded(GetHashKey(vehicleModel))
        
        -- Fade in
        DoScreenFadeIn(500)
        while not IsScreenFadedIn() do
            Wait(10)
        end
        
        -- Marquer comme en jeu
        inGame = true
        
        -- Notification de dÃ©marrage
        ShowGameNotification(Config.CoursePoursuit.Notifications.starting, 3000, 'info')
        Wait(3000)
        ShowGameNotification(Config.CoursePoursuit.Notifications.started, 3000, 'success')
        
        -- Calculer l'heure de fin si durÃ©e dÃ©finie
        if Config.CoursePoursuit.GameDuration > 0 then
            gameEndTime = GetGameTimer() + (Config.CoursePoursuit.GameDuration * 1000)
        end
        
        -- Spawner un bot si mode solo activÃ©
        if data.spawnBot then
            Config.InfoPrint('Mode solo dÃ©tectÃ©, spawn du bot...')
            Wait(2000) -- Attendre 2 secondes pour que tout soit stable
            SpawnBotAdversary()
        end
        
        -- DÃ©marrer les threads de gestion
        StartGameThreads()
        
        Config.SuccessPrint('Course Poursuite dÃ©marrÃ©e!')
    end)
    
    -- Si erreur, restaurer l'Ã©cran et nettoyer
    if not success then
        Config.ErrorPrint('ERREUR lors du dÃ©marrage: ' .. tostring(err))
        
        -- TOUJOURS faire le fade in pour Ã©viter Ã©cran noir
        if IsScreenFadedOut() then
            DoScreenFadeIn(500)
        end
        
        -- Nettoyer
        if DoesEntityExist(currentVehicle) then
            DeleteEntity(currentVehicle)
            currentVehicle = nil
        end
        
        -- Notification d'erreur
        ShowGameNotification('âŒ Erreur lors du dÃ©marrage: ' .. tostring(err), 5000, 'error')
        
        -- PrÃ©venir le serveur
        TriggerServerEvent('scharman:server:coursePoursuiteLeft', instanceId)
        
        inGame = false
        instanceId = nil
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ARRÃŠT DU JEU
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- ArrÃªter le jeu
local function StopCoursePoursuiteGame()
    if not inGame then
        Config.DebugPrint('Pas en jeu')
        return
    end
    
    Config.InfoPrint('ArrÃªt du mode Course Poursuite, nettoyage...')
    
    -- Marquer comme pas en jeu
    inGame = false
    
    -- ArrÃªter les threads
    blockExitThread = nil
    zoneCheckThread = nil
    gameEndTime = nil
    
    local ped = PlayerPedId()
    
    -- TÃ©lÃ©porter le joueur Ã  la position de retour
    if Config.CoursePoursuit.ReturnToNormalCoords then
        DoScreenFadeOut(500)
        Wait(500)
        
        local returnCoords = Config.CoursePoursuit.ReturnToNormalCoords
        SetEntityCoords(ped, returnCoords.x, returnCoords.y, returnCoords.z, false, false, false, true)
        SetEntityHeading(ped, returnCoords.w)
        
        Wait(500)
        DoScreenFadeIn(500)
    end
    
    -- Supprimer le vÃ©hicule
    if DoesEntityExist(currentVehicle) then
        DeleteEntity(currentVehicle)
        currentVehicle = nil
        Config.DebugPrint('VÃ©hicule supprimÃ©')
    end
    
    -- Supprimer le bot
    DeleteBot()
    
    -- RÃ©initialiser instanceId
    instanceId = nil
    
    Config.SuccessPrint('Nettoyage terminÃ©')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- THREADS DE GESTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Thread de blocage de sortie du vÃ©hicule
local function StartBlockExitThread()
    if blockExitThread then return end
    
    Config.DebugPrint('Thread de blocage de sortie dÃ©marrÃ©')
    
    blockExitThread = CreateThread(function()
        while inGame and Config.CoursePoursuit.BlockExitVehicle do
            Wait(0)
            
            local ped = PlayerPedId()
            
            -- Bloquer la touche F (sortir du vÃ©hicule)
            DisableControlAction(0, 75, true) -- INPUT_VEH_EXIT
            
            -- Si le joueur essaye de sortir
            if IsDisabledControlJustPressed(0, 75) then
                ShowGameNotification(Config.CoursePoursuit.BlockExitMessage, 3000, 'warning')
                Config.DebugPrint('Tentative de sortie bloquÃ©e')
            end
            
            -- Si le joueur est sorti (par un bug), le remettre dans le vÃ©hicule
            if DoesEntityExist(currentVehicle) and not IsPedInVehicle(ped, currentVehicle, false) then
                TaskWarpPedIntoVehicle(ped, currentVehicle, -1)
                ShowGameNotification('ðŸš— Retour forcÃ© dans le vÃ©hicule !', 3000, 'warning')
                Config.DebugPrint('Joueur remis dans le vÃ©hicule')
            end
        end
        
        blockExitThread = nil
        Config.DebugPrint('Thread de blocage de sortie arrÃªtÃ©')
    end)
end

-- Thread de vÃ©rification de zone
local function StartZoneCheckThread()
    if not Config.CoursePoursuit.UseZoneLimit then return end
    if zoneCheckThread then return end
    
    Config.DebugPrint('Thread de vÃ©rification de zone dÃ©marrÃ©')
    
    zoneCheckThread = CreateThread(function()
        local timeOutOfZone = 0
        
        while inGame do
            Wait(1000) -- VÃ©rifier chaque seconde
            
            local ped = PlayerPedId()
            local playerCoords = GetEntityCoords(ped)
            local zoneCenter = Config.CoursePoursuit.SpawnCoords
            local distance = #(playerCoords - vector3(zoneCenter.x, zoneCenter.y, zoneCenter.z))
            
            if distance > Config.CoursePoursuit.ZoneRadius then
                timeOutOfZone = timeOutOfZone + 1
                
                if timeOutOfZone == 1 then
                    ShowGameNotification('âš ï¸ Retournez dans la zone de jeu !', 3000, 'warning')
                end
                
                if timeOutOfZone >= Config.CoursePoursuit.OutOfZoneTimeout then
                    ShowGameNotification('ðŸš« Trop loin de la zone ! TÃ©lÃ©portation...', 3000, 'error')
                    
                    -- TÃ©lÃ©porter dans la zone
                    SetEntityCoords(ped, zoneCenter.x, zoneCenter.y, zoneCenter.z, false, false, false, true)
                    timeOutOfZone = 0
                end
            else
                timeOutOfZone = 0
            end
        end
        
        zoneCheckThread = nil
        Config.DebugPrint('Thread de vÃ©rification de zone arrÃªtÃ©')
    end)
end

-- Thread du timer de jeu
local function StartGameTimerThread()
    if Config.CoursePoursuit.GameDuration <= 0 then return end
    
    Config.DebugPrint('Thread timer de jeu dÃ©marrÃ©')
    
    CreateThread(function()
        while inGame and gameEndTime do
            Wait(1000) -- VÃ©rifier chaque seconde
            
            local timeLeft = gameEndTime - GetGameTimer()
            
            if timeLeft <= 0 then
                ShowGameNotification('â±ï¸ Temps Ã©coulÃ© ! Fin de la partie.', 5000, 'info')
                StopCoursePoursuiteGame()
                TriggerServerEvent('scharman:server:coursePoursuiteLeft', instanceId)
                break
            end
        end
        
        Config.DebugPrint('Thread timer de jeu arrÃªtÃ©')
    end)
end

-- DÃ©marrer tous les threads
function StartGameThreads()
    StartBlockExitThread()
    StartZoneCheckThread()
    StartGameTimerThread()
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ã‰VÃ‰NEMENTS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- DÃ©marrer le jeu
RegisterNetEvent('scharman:client:startCoursePoursuit', function(data)
    StartCoursePoursuiteGame(data)
end)

-- ArrÃªter le jeu
RegisterNetEvent('scharman:client:stopCoursePoursuit', function()
    StopCoursePoursuiteGame()
end)

-- Notification
RegisterNetEvent('scharman:client:courseNotification', function(message, duration, notifType)
    ShowGameNotification(message, duration or 3000, notifType or 'info')
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- COMMANDES DEBUG
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if Config.Debug then
    RegisterCommand('course_stop', function()
        if inGame then
            StopCoursePoursuiteGame()
            TriggerServerEvent('scharman:server:coursePoursuiteLeft', instanceId)
            Config.InfoPrint('Course arrÃªtÃ©e manuellement')
        else
            Config.ErrorPrint('Tu n\'es pas en jeu')
        end
    end, false)
    
    RegisterCommand('course_info', function()
        print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
        print('Ã‰tat du jeu: ' .. (inGame and 'EN JEU' or 'PAS EN JEU'))
        print('Instance: ' .. (instanceId or 'Aucune'))
        print('VÃ©hicule: ' .. (currentVehicle or 'Aucun'))
        print('Bot PED: ' .. (botPed or 'Aucun'))
        print('Bot VÃ©hicule: ' .. (botVehicle or 'Aucun'))
        if gameEndTime then
            local timeLeft = gameEndTime - GetGameTimer()
            print('Temps restant: ' .. math.floor(timeLeft / 1000) .. 's')
        end
        print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    end, false)
    
    Config.InfoPrint('Commandes de debug Course Poursuite disponibles')
    Config.InfoPrint('- /course_stop : ArrÃªter le jeu')
    Config.InfoPrint('- /course_info : Afficher les informations')
end

Config.DebugPrint('Fichier client/course_poursuite.lua chargÃ© avec succÃ¨s')
