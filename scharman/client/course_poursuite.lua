-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
-- â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘
-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘
-- â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
-- â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•
-- CLIENT - MODE COURSE POURSUITE V2 (CORRIGÃ‰)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- VARIABLES LOCALES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local inGame = false
local currentVehicle = nil
local instanceId = nil
local currentBucket = 0
local blockExitThread = nil
local zoneCheckThread = nil
local gameEndTime = nil
local gameStartTime = nil
local botPed = nil
local botVehicle = nil

-- âœ… ZONE DE GUERRE
local canExitVehicle = false
local warZoneActive = false
local warZonePosition = nil
local warZoneBlip = nil
local warZoneCenterBlip = nil
local warZoneThread = nil
local warZoneRadius = 50.0
local zoneCreatedOnExit = false -- âœ… CORRIGÃ‰: Variable globale

-- âœ… DÃ‰COMPTE
local countdownActive = false

-- âœ… NOUVEAUX: Pour gestion dÃ©gÃ¢ts et mort
local damageZoneThread = nil
local vehicleExitThread = nil
local warningMessageActive = false

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FORWARD DECLARATIONS (Fonctions appelÃ©es avant leur dÃ©finition)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local StartDamageZoneThread  -- DÃ©clarÃ© ici, dÃ©fini plus tard

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FONCTIONS UTILITAIRES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function ShowGameNotification(message, duration, notifType)
    SendNUIMessage({
        action = 'showNotification',
        data = {
            message = message,
            duration = duration or Config.CoursePoursuit.MessageDuration,
            type = notifType or 'info'
        }
    })
end

local function LoadModel(model)
    local modelHash = GetHashKey(model)
    
    if not IsModelValid(modelHash) then
        Config.ErrorPrint('ModÃ¨le invalide: ' .. model)
        return false
    end
    
    Config.DebugPrint('Demande de chargement du modÃ¨le: ' .. model)
    RequestModel(modelHash)
    
    local timeout = 0
    while not HasModelLoaded(modelHash) do
        Wait(100)
        timeout = timeout + 100
        
        if timeout >= 10000 then
            Config.ErrorPrint('Timeout lors du chargement du modÃ¨le: ' .. model)
            return false
        end
    end
    
    Config.SuccessPrint('ModÃ¨le chargÃ©: ' .. model)
    return true
end

local function ForcePlayerIntoVehicle(ped, vehicle, seat)
    Config.DebugPrint('Tentative de placement du joueur dans le vÃ©hicule...')
    
    if not DoesEntityExist(vehicle) then
        Config.ErrorPrint('Le vÃ©hicule n\'existe pas!')
        return false
    end
    
    if not DoesEntityExist(ped) then
        Config.ErrorPrint('Le PED n\'existe pas!')
        return false
    end
    
    SetVehicleOnGroundProperly(vehicle)
    Wait(100)
    
    Config.DebugPrint('Ã‰tat avant placement:')
    Config.DebugPrint('- VÃ©hicule existe: ' .. tostring(DoesEntityExist(vehicle)))
    Config.DebugPrint('- PED existe: ' .. tostring(DoesEntityExist(ped)))
    Config.DebugPrint('- SiÃ¨ge: ' .. tostring(seat))
    
    TaskWarpPedIntoVehicle(ped, vehicle, seat)
    Wait(500)
    
    local attempts = 0
    local maxAttempts = 10
    
    while GetVehiclePedIsIn(ped, false) ~= vehicle and attempts < maxAttempts do
        attempts = attempts + 1
        Config.DebugPrint('Tentative ' .. attempts .. '/' .. maxAttempts .. ' de placement...')
        
        TaskWarpPedIntoVehicle(ped, vehicle, seat)
        Wait(300)
        
        if GetVehiclePedIsIn(ped, false) ~= vehicle then
            Config.DebugPrint('TaskWarp Ã©chouÃ©, essai avec SetPedIntoVehicle...')
            SetPedIntoVehicle(ped, vehicle, seat)
            Wait(300)
        end
    end
    
    local currentVeh = GetVehiclePedIsIn(ped, false)
    local isInVehicle = currentVeh == vehicle
    
    Config.DebugPrint('Ã‰tat aprÃ¨s placement:')
    Config.DebugPrint('- VÃ©hicule actuel: ' .. tostring(currentVeh))
    Config.DebugPrint('- VÃ©hicule cible: ' .. tostring(vehicle))
    Config.DebugPrint('- Dans le vÃ©hicule: ' .. tostring(isInVehicle))
    Config.DebugPrint('- Tentatives: ' .. attempts)
    
    if isInVehicle then
        Config.SuccessPrint('Joueur placÃ© dans le vÃ©hicule avec succÃ¨s!')
        return true
    else
        Config.ErrorPrint('Ã‰CHEC: Le joueur n\'est pas dans le vÃ©hicule aprÃ¨s ' .. attempts .. ' tentatives')
        return false
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ZONE DE GUERRE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartWarZoneThread()
    if warZoneThread then return end
    
    Config.InfoPrint('Thread de rendu zone de guerre dÃ©marrÃ©')
    
    warZoneThread = CreateThread(function()
        while inGame and warZoneActive do
            Wait(0)
            
            if not warZonePosition then
                Wait(100)
                goto continue
            end
            
            local pos = warZonePosition
            
            -- Colonne de lumiÃ¨re rouge (cylindre vertical)
            DrawMarker(
                28,
                pos.x, pos.y, pos.z,
                0.0, 0.0, 0.0,
                0.0, 0.0, 0.0,
                warZoneRadius, warZoneRadius, 150.0,
                255, 0, 0, 100,
                false, false, 2, false, nil, nil, false
            )
            
            -- Cercle au sol
            DrawMarker(
                1,
                pos.x, pos.y, pos.z - 1.0,
                0.0, 0.0, 0.0,
                0.0, 0.0, 0.0,
                warZoneRadius * 2, warZoneRadius * 2, 1.0,
                255, 0, 0, 150,
                false, false, 2, false, nil, nil, false
            )
            
            ::continue::
        end
        
        warZoneThread = nil
        Config.DebugPrint('Thread de rendu zone de guerre arrÃªtÃ©')
    end)
end

local function CreateWarZone(position)
    Config.InfoPrint('ğŸ”´ CRÃ‰ATION ZONE DE GUERRE')
    Config.DebugPrint('[CREATE ZONE] Position: ' .. tostring(position))
    
    warZonePosition = position
    warZoneActive = true
    zoneCreatedOnExit = true -- âœ… IMPORTANT: Marquer la zone comme crÃ©Ã©e
    
    Config.DebugPrint('[CREATE ZONE] Variables mises Ã  jour:')
    Config.DebugPrint('[CREATE ZONE] - warZonePosition: ' .. tostring(warZonePosition))
    Config.DebugPrint('[CREATE ZONE] - warZoneActive: ' .. tostring(warZoneActive))
    Config.DebugPrint('[CREATE ZONE] - zoneCreatedOnExit: ' .. tostring(zoneCreatedOnExit))
    
    -- CrÃ©er le blip de rayon (zone rouge)
    if warZoneBlip then
        RemoveBlip(warZoneBlip)
    end
    
    warZoneBlip = AddBlipForRadius(position.x, position.y, position.z, warZoneRadius)
    SetBlipHighDetail(warZoneBlip, true)
    SetBlipColour(warZoneBlip, 1) -- Rouge
    SetBlipAlpha(warZoneBlip, 180)
    
    Config.DebugPrint('[CREATE ZONE] Blip rayon crÃ©Ã©')
    
    -- CrÃ©er le blip centre (crÃ¢ne)
    if warZoneCenterBlip then
        RemoveBlip(warZoneCenterBlip)
    end
    
    warZoneCenterBlip = AddBlipForCoord(position.x, position.y, position.z)
    SetBlipSprite(warZoneCenterBlip, 84) -- CrÃ¢ne
    SetBlipDisplay(warZoneCenterBlip, 4)
    SetBlipScale(warZoneCenterBlip, 1.2)
    SetBlipColour(warZoneCenterBlip, 1) -- Rouge
    SetBlipAsShortRange(warZoneCenterBlip, false)
    BeginTextCommandSetBlipName("STRING")
    AddTextComponentString("ğŸ”´ ZONE DE GUERRE")
    EndTextCommandSetBlipName(warZoneCenterBlip)
    
    Config.DebugPrint('[CREATE ZONE] Blip centre crÃ©Ã©')
    
    Config.SuccessPrint('Zone de guerre crÃ©Ã©e Ã  la position: ' .. tostring(position))
    Config.InfoPrint('[CREATE ZONE] Rayon: ' .. warZoneRadius .. 'm')
    
    -- DÃ©marrer le thread de rendu
    StartWarZoneThread()
    
    -- âœ… NOUVEAU: Faire que le bot se dirige vers la zone de guerre
    if botPed and DoesEntityExist(botPed) and botVehicle and DoesEntityExist(botVehicle) then
        Config.InfoPrint('[CREATE ZONE] ğŸ¤– Redirection bot vers zone de guerre')
        
        -- ArrÃªter l'ancienne tÃ¢che
        ClearPedTasks(botPed)
        
        -- Diriger le bot vers le centre de la zone
        TaskVehicleDriveToCoordLongrange(
            botPed, 
            botVehicle, 
            position.x, 
            position.y, 
            position.z, 
            Config.CoursePoursuit.BotSpeed, 
            Config.CoursePoursuit.BotDrivingStyle, 
            20.0  -- Distance d'arrÃªt
        )
        
        Config.SuccessPrint('[CREATE ZONE] âœ… Bot va maintenant vers la zone !')
    end
    
    -- âœ… CORRECTION CRITIQUE: DÃ©marrer le thread de dÃ©gÃ¢ts MAINTENANT que la zone existe
    Config.InfoPrint('[CREATE ZONE] DÃ©marrage thread dÃ©gÃ¢ts zone...')
    StartDamageZoneThread()
end

local function DeleteWarZone()
    Config.DebugPrint('Suppression de la zone de guerre...')
    
    warZoneActive = false
    warZonePosition = nil
    zoneCreatedOnExit = false
    
    if warZoneBlip then
        RemoveBlip(warZoneBlip)
        warZoneBlip = nil
    end
    
    if warZoneCenterBlip then
        RemoveBlip(warZoneCenterBlip)
        warZoneCenterBlip = nil
    end
    
    if warZoneThread then
        warZoneThread = nil
    end
    
    Config.SuccessPrint('Zone de guerre supprimÃ©e')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DÃ‰COMPTE 3-2-1-GO
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartCountdown()
    Config.InfoPrint('â±ï¸ DÃ‰MARRAGE DU DÃ‰COMPTE')
    
    countdownActive = true
    
    -- Bloquer les contrÃ´les pendant le dÃ©compte
    local ped = PlayerPedId()
    FreezeEntityPosition(ped, true)
    
    -- 3
    SendNUIMessage({
        action = 'showCountdown',
        data = { number = 3 }
    })
    PlaySoundFrontend(-1, 'CHECKPOINT_NORMAL', 'HUD_MINI_GAME_SOUNDSET', true)
    Wait(1000)
    
    -- 2
    SendNUIMessage({
        action = 'showCountdown',
        data = { number = 2 }
    })
    PlaySoundFrontend(-1, 'CHECKPOINT_NORMAL', 'HUD_MINI_GAME_SOUNDSET', true)
    Wait(1000)
    
    -- 1
    SendNUIMessage({
        action = 'showCountdown',
        data = { number = 1 }
    })
    PlaySoundFrontend(-1, 'CHECKPOINT_NORMAL', 'HUD_MINI_GAME_SOUNDSET', true)
    Wait(1000)
    
    -- GO!
    SendNUIMessage({
        action = 'showCountdown',
        data = { number = 'GO!' }
    })
    PlaySoundFrontend(-1, 'RACE_PLACED', 'HUD_AWARDS', true)
    
    -- DÃ©bloquer
    FreezeEntityPosition(ped, false)
    
    Wait(1000)
    
    -- Cacher le dÃ©compte
    SendNUIMessage({
        action = 'hideCountdown'
    })
    
    countdownActive = false
    Config.SuccessPrint('âœ… DÃ©compte terminÃ© - C\'EST PARTI!')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FONCTIONS BOT (CORRIGÃ‰)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function DeleteBot()
    Config.DebugPrint('Suppression du bot...')
    
    if DoesEntityExist(botVehicle) then
        DeleteEntity(botVehicle)
        botVehicle = nil
        Config.DebugPrint('VÃ©hicule bot supprimÃ©')
    end
    
    if DoesEntityExist(botPed) then
        DeleteEntity(botPed)
        botPed = nil
        Config.DebugPrint('Bot supprimÃ©')
    end
    
    Config.SuccessPrint('Bot nettoyÃ©')
end

local function SpawnBotAdversary()
    if not Config.CoursePoursuit.SpawnBotInSolo then
        Config.DebugPrint('[BOT] Spawn dÃ©sactivÃ© dans config')
        return false
    end
    
    Config.InfoPrint('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—')
    Config.InfoPrint('â•‘     DÃ‰BUT SPAWN BOT ADVERSAIRE        â•‘')
    Config.InfoPrint('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    
    local ped = PlayerPedId()
    local playerCoords = GetEntityCoords(ped)
    local playerHeading = GetEntityHeading(ped)
    
    -- âœ… VÃ©rification bucket
    Config.DebugPrint('[BOT] Ã‰TAPE 1/12: VÃ©rification bucket')
    if currentBucket == 0 then
        Config.ErrorPrint('[BOT] âŒ Bucket invalide (0) - Attente...')
        Wait(2000)
        if currentBucket == 0 then
            Config.ErrorPrint('[BOT] âŒ Bucket toujours invalide - ANNULATION')
            return false
        end
    end
    Config.SuccessPrint('[BOT] âœ… Bucket valide: ' .. currentBucket)
    
    -- âœ… Calcul position spawn
    Config.DebugPrint('[BOT] Ã‰TAPE 2/12: Calcul position spawn')
    local offset = Config.CoursePoursuit.BotSpawnOffset
    local forwardX = math.cos(math.rad(playerHeading))
    local forwardY = math.sin(math.rad(playerHeading))
    
    local botCoords = vector3(
        playerCoords.x + (forwardX * offset.x) + offset.y,
        playerCoords.y + (forwardY * offset.x),
        playerCoords.z + offset.z
    )
    Config.DebugPrint('[BOT] Position calculÃ©e: ' .. tostring(botCoords))
    
    -- âœ… Chargement modÃ¨le PED
    Config.DebugPrint('[BOT] Ã‰TAPE 3/12: Chargement modÃ¨le PED')
    Config.DebugPrint('[BOT] ModÃ¨le demandÃ©: ' .. Config.CoursePoursuit.BotModel)
    
    if not LoadModel(Config.CoursePoursuit.BotModel) then
        Config.ErrorPrint('[BOT] âŒ Ã‰chec chargement modÃ¨le')
        return false
    end
    Config.SuccessPrint('[BOT] âœ… ModÃ¨le chargÃ©')
    
    local modelHash = GetHashKey(Config.CoursePoursuit.BotModel)
    Config.DebugPrint('[BOT] Hash modÃ¨le: ' .. tostring(modelHash))
    Config.DebugPrint('[BOT] ModÃ¨le valide: ' .. tostring(IsModelValid(modelHash)))
    Config.DebugPrint('[BOT] ModÃ¨le dans mÃ©moire: ' .. tostring(IsModelInCdimage(modelHash)))
    
    -- âœ… CRITIQUE: DÃ©sactiver la population pour forcer le spawn
    Config.DebugPrint('[BOT] Ã‰TAPE 4/12: DÃ©sactivation population temporaire')
    SetPedPopulationBudget(0)
    SetVehiclePopulationBudget(0)
    Config.DebugPrint('[BOT] Population dÃ©sactivÃ©e')
    
    Wait(500)
    
    -- âœ… CrÃ©ation PED en LOCAL (pas networked)
    Config.DebugPrint('[BOT] Ã‰TAPE 5/12: CrÃ©ation PED LOCAL')
    Config.DebugPrint('[BOT] ParamÃ¨tres:')
    Config.DebugPrint('[BOT] - Type: 4 (PED_TYPE_CIVMALE)')
    Config.DebugPrint('[BOT] - Hash: ' .. modelHash)
    Config.DebugPrint('[BOT] - X: ' .. botCoords.x)
    Config.DebugPrint('[BOT] - Y: ' .. botCoords.y)
    Config.DebugPrint('[BOT] - Z: ' .. botCoords.z)
    Config.DebugPrint('[BOT] - Heading: ' .. playerHeading)
    Config.DebugPrint('[BOT] - Network: false (LOCAL)')
    Config.DebugPrint('[BOT] - Mission: false')
    
    -- âœ… CrÃ©er en LOCAL pour Ã©viter les problÃ¨mes de rÃ©seau
    botPed = CreatePed(4, modelHash, botCoords.x, botCoords.y, botCoords.z, playerHeading, false, false)
    
    Config.DebugPrint('[BOT] CreatePed() retournÃ©: ' .. tostring(botPed))
    Config.DebugPrint('[BOT] Type retournÃ©: ' .. type(botPed))
    
    if botPed == 0 or botPed == nil then
        Config.ErrorPrint('[BOT] âŒ CreatePed a retournÃ© 0 ou nil!')
        SetPedPopulationBudget(3)
        SetVehiclePopulationBudget(3)
        SetModelAsNoLongerNeeded(modelHash)
        return false
    end
    
    -- âœ… Attente crÃ©ation avec vÃ©rifications ultra-dÃ©taillÃ©es
    Config.DebugPrint('[BOT] Ã‰TAPE 6/12: Attente crÃ©ation PED (max 10s)')
    
    local attempts = 0
    local maxAttempts = 50 -- 50 Ã— 200ms = 10 secondes
    local pedExists = false
    
    while attempts < maxAttempts do
        Wait(200)
        attempts = attempts + 1
        
        pedExists = DoesEntityExist(botPed)
        
        -- Log dÃ©taillÃ© tous les 5 essais
        if attempts % 5 == 0 then
            Config.DebugPrint(string.format('[BOT] Tentative %d/%d:', attempts, maxAttempts))
            Config.DebugPrint('[BOT]   DoesEntityExist: ' .. tostring(pedExists))
            Config.DebugPrint('[BOT]   IsEntityAPed: ' .. tostring(IsEntityAPed(botPed)))
            Config.DebugPrint('[BOT]   GetEntityType: ' .. tostring(GetEntityType(botPed)))
            
            if pedExists then
                local coords = GetEntityCoords(botPed)
                Config.DebugPrint('[BOT]   Position: ' .. tostring(coords))
                Config.DebugPrint('[BOT]   Health: ' .. tostring(GetEntityHealth(botPed)))
            end
        end
        
        if pedExists then
            Config.SuccessPrint(string.format('[BOT] âœ… PED existe aprÃ¨s %.1fs (%d tentatives)', attempts * 0.2, attempts))
            break
        end
    end
    
    -- âœ… RÃ©activer la population
    Config.DebugPrint('[BOT] Ã‰TAPE 7/12: RÃ©activation population')
    SetPedPopulationBudget(3)
    SetVehiclePopulationBudget(3)
    Config.DebugPrint('[BOT] Population rÃ©activÃ©e')
    
    if not pedExists then
        Config.ErrorPrint('[BOT] âŒ Ã‰CHEC CRITIQUE: PED n\'existe pas aprÃ¨s 10 secondes!')
        Config.ErrorPrint('[BOT] DÃ©tails:')
        Config.ErrorPrint('[BOT]   Entity ID: ' .. tostring(botPed))
        Config.ErrorPrint('[BOT]   DoesEntityExist: ' .. tostring(DoesEntityExist(botPed)))
        Config.ErrorPrint('[BOT]   IsEntityAPed: ' .. tostring(IsEntityAPed(botPed)))
        Config.ErrorPrint('[BOT]   GetEntityType: ' .. tostring(GetEntityType(botPed)))
        
        DeleteEntity(botPed)
        botPed = nil
        SetModelAsNoLongerNeeded(modelHash)
        return false
    end
    
    Config.SuccessPrint('[BOT] âœ… PED crÃ©Ã© avec succÃ¨s (ID: ' .. botPed .. ')')
    
    -- âœ… Configuration PED
    Config.DebugPrint('[BOT] Ã‰TAPE 8/12: Configuration PED')
    
    -- âš ï¸ IMPORTANT: SetEntityRoutingBucket() est SERVEUR uniquement !
    -- Le bot LOCAL hÃ©rite automatiquement du bucket du joueur
    Config.DebugPrint('[BOT] Note: Bot LOCAL hÃ©rite du bucket joueur (' .. currentBucket .. ') automatiquement')
    
    SetEntityInvincible(botPed, true)
    SetBlockingOfNonTemporaryEvents(botPed, true)
    SetPedCanRagdoll(botPed, false)
    SetPedFleeAttributes(botPed, 0, false)
    SetPedCombatAttributes(botPed, 17, true)
    
    Wait(500)
    
    Config.SuccessPrint('[BOT] âœ… PED configurÃ© (invincible, no ragdoll, bucket ' .. currentBucket .. ')')
    
    -- âœ… Chargement modÃ¨le vÃ©hicule
    Config.DebugPrint('[BOT] Ã‰TAPE 9/12: Chargement modÃ¨le vÃ©hicule')
    Config.DebugPrint('[BOT] ModÃ¨le vÃ©hicule: ' .. Config.CoursePoursuit.BotVehicle)
    
    if not LoadModel(Config.CoursePoursuit.BotVehicle) then
        Config.ErrorPrint('[BOT] âŒ Ã‰chec chargement modÃ¨le vÃ©hicule')
        DeleteEntity(botPed)
        botPed = nil
        return false
    end
    Config.SuccessPrint('[BOT] âœ… ModÃ¨le vÃ©hicule chargÃ©')
    
    local vehicleHash = GetHashKey(Config.CoursePoursuit.BotVehicle)
    Config.DebugPrint('[BOT] Hash vÃ©hicule: ' .. tostring(vehicleHash))
    
    -- âœ… DÃ©sactiver population Ã  nouveau
    SetVehiclePopulationBudget(0)
    Wait(300)
    
    -- âœ… CrÃ©ation vÃ©hicule en LOCAL
    Config.DebugPrint('[BOT] Ã‰TAPE 10/12: CrÃ©ation vÃ©hicule LOCAL')
    botVehicle = CreateVehicle(vehicleHash, botCoords.x, botCoords.y, botCoords.z, playerHeading, false, false)
    
    Config.DebugPrint('[BOT] CreateVehicle() retournÃ©: ' .. tostring(botVehicle))
    
    if botVehicle == 0 or botVehicle == nil then
        Config.ErrorPrint('[BOT] âŒ CreateVehicle a retournÃ© 0 ou nil!')
        SetVehiclePopulationBudget(3)
        DeleteEntity(botPed)
        botPed = nil
        SetModelAsNoLongerNeeded(vehicleHash)
        return false
    end
    
    -- âœ… Attente crÃ©ation vÃ©hicule
    Config.DebugPrint('[BOT] Attente crÃ©ation vÃ©hicule (max 10s)')
    
    attempts = 0
    maxAttempts = 50
    local vehicleExists = false
    
    while attempts < maxAttempts do
        Wait(200)
        attempts = attempts + 1
        
        vehicleExists = DoesEntityExist(botVehicle)
        
        if attempts % 5 == 0 then
            Config.DebugPrint(string.format('[BOT] Tentative %d/%d:', attempts, maxAttempts))
            Config.DebugPrint('[BOT]   DoesEntityExist: ' .. tostring(vehicleExists))
            Config.DebugPrint('[BOT]   IsEntityAVehicle: ' .. tostring(IsEntityAVehicle(botVehicle)))
            
            if vehicleExists then
                local coords = GetEntityCoords(botVehicle)
                Config.DebugPrint('[BOT]   Position: ' .. tostring(coords))
            end
        end
        
        if vehicleExists then
            Config.SuccessPrint(string.format('[BOT] âœ… VÃ©hicule existe aprÃ¨s %.1fs (%d tentatives)', attempts * 0.2, attempts))
            break
        end
    end
    
    -- âœ… RÃ©activer population
    SetVehiclePopulationBudget(3)
    
    if not vehicleExists then
        Config.ErrorPrint('[BOT] âŒ Ã‰CHEC: VÃ©hicule n\'existe pas aprÃ¨s 10 secondes!')
        Config.ErrorPrint('[BOT] Entity ID: ' .. tostring(botVehicle))
        DeleteEntity(botPed)
        botPed = nil
        DeleteEntity(botVehicle)
        botVehicle = nil
        SetModelAsNoLongerNeeded(vehicleHash)
        return false
    end
    
    Config.SuccessPrint('[BOT] âœ… VÃ©hicule crÃ©Ã© (ID: ' .. botVehicle .. ')')
    
    -- âœ… Configuration vÃ©hicule
    Config.DebugPrint('[BOT] Configuration vÃ©hicule...')
    
    -- âš ï¸ IMPORTANT: SetEntityRoutingBucket() est SERVEUR uniquement !
    -- Le vÃ©hicule LOCAL hÃ©rite automatiquement du bucket du joueur
    Config.DebugPrint('[BOT] Note: VÃ©hicule LOCAL hÃ©rite du bucket joueur (' .. currentBucket .. ') automatiquement')
    
    local botColor = Config.CoursePoursuit.BotVehicleColor
    SetVehicleCustomPrimaryColour(botVehicle, botColor.primary.r, botColor.primary.g, botColor.primary.b)
    SetVehicleCustomSecondaryColour(botVehicle, botColor.secondary.r, botColor.secondary.g, botColor.secondary.b)
    SetVehicleNumberPlateText(botVehicle, 'BOT~AI')
    SetVehicleEngineHealth(botVehicle, 1000.0)
    SetVehicleBodyHealth(botVehicle, 1000.0)
    SetVehicleOnGroundProperly(botVehicle)
    
    Wait(1000)
    
    Config.SuccessPrint('[BOT] âœ… VÃ©hicule configurÃ©')
    
    -- âœ… Placement bot dans vÃ©hicule
    Config.DebugPrint('[BOT] Ã‰TAPE 11/12: Placement bot dans vÃ©hicule')
    
    TaskWarpPedIntoVehicle(botPed, botVehicle, -1)
    Wait(1000)
    
    attempts = 0
    maxAttempts = 15
    local botInVehicle = false
    
    while attempts < maxAttempts do
        attempts = attempts + 1
        
        local currentVeh = GetVehiclePedIsIn(botPed, false)
        botInVehicle = (currentVeh == botVehicle)
        
        if attempts % 3 == 0 then
            Config.DebugPrint(string.format('[BOT] Placement tentative %d/%d:', attempts, maxAttempts))
            Config.DebugPrint('[BOT]   VÃ©hicule cible: ' .. botVehicle)
            Config.DebugPrint('[BOT]   VÃ©hicule actuel: ' .. currentVeh)
            Config.DebugPrint('[BOT]   Dans vÃ©hicule: ' .. tostring(botInVehicle))
        end
        
        if botInVehicle then
            Config.SuccessPrint('[BOT] âœ… Bot placÃ© dans vÃ©hicule aprÃ¨s ' .. attempts .. ' tentatives')
            break
        end
        
        -- RÃ©essayer
        TaskWarpPedIntoVehicle(botPed, botVehicle, -1)
        Wait(500)
        
        if attempts > 5 then
            SetPedIntoVehicle(botPed, botVehicle, -1)
            Wait(500)
        end
    end
    
    if not botInVehicle then
        Config.ErrorPrint('[BOT] âŒ Ã‰CHEC: Bot pas dans vÃ©hicule aprÃ¨s ' .. attempts .. ' tentatives!')
        DeleteBot()
        return false
    end
    
    -- âœ… Configuration conduite
    Config.DebugPrint('[BOT] Ã‰TAPE 12/12: Configuration conduite')
    
    if Config.CoursePoursuit.BotRandomRoute then
        Config.DebugPrint('[BOT] Mode: Conduite alÃ©atoire (Wander)')
        TaskVehicleDriveWander(botPed, botVehicle, Config.CoursePoursuit.BotSpeed, Config.CoursePoursuit.BotDrivingStyle)
    else
        local targetCoords = vector3(botCoords.x + 500.0, botCoords.y + 500.0, botCoords.z)
        Config.DebugPrint('[BOT] Mode: Conduite vers point')
        TaskVehicleDriveToCoordLongrange(botPed, botVehicle, targetCoords.x, targetCoords.y, targetCoords.z, Config.CoursePoursuit.BotSpeed, Config.CoursePoursuit.BotDrivingStyle, 10.0)
    end
    
    -- âœ… LibÃ©rer modÃ¨les
    SetModelAsNoLongerNeeded(modelHash)
    SetModelAsNoLongerNeeded(vehicleHash)
    
    Config.InfoPrint('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—')
    Config.InfoPrint('â•‘   SPAWN BOT RÃ‰USSI - 100% COMPLET    â•‘')
    Config.InfoPrint('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    Config.SuccessPrint('[BOT] ğŸ¤– Bot PED ID: ' .. botPed)
    Config.SuccessPrint('[BOT] ğŸš™ Bot Vehicle ID: ' .. botVehicle)
    Config.SuccessPrint('[BOT] ğŸª£ Bucket: ' .. currentBucket)
    Config.SuccessPrint('[BOT] âœ… Bot configurÃ© et en conduite!')
    
    ShowGameNotification('ğŸ¤– Un adversaire bot est apparu !', 4000, 'success')
    
    return true
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DÃ‰MARRAGE DU JEU
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartCoursePoursuiteGame(data)
    if inGame then
        Config.DebugPrint('DÃ©jÃ  en jeu')
        return
    end
    
    Config.InfoPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    Config.InfoPrint('DÃ‰MARRAGE DE LA COURSE POURSUITE V2')
    Config.InfoPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    
    local success, err = pcall(function()
        local ped = PlayerPedId()
        instanceId = data.instanceId
        
        local spawnCoords = data.spawnCoords or Config.CoursePoursuit.SpawnCoords
        local vehicleModel = data.vehicleModel or Config.CoursePoursuit.VehicleModel
        
        ShowGameNotification(Config.CoursePoursuit.Notifications.teleporting, 2000, 'info')
        
        DoScreenFadeOut(800)
        while not IsScreenFadedOut() do Wait(10) end
        
        SetEntityCoords(ped, spawnCoords.x, spawnCoords.y, spawnCoords.z, false, false, false, true)
        SetEntityHeading(ped, spawnCoords.w)
        
        -- âœ… CORRECTION: Stocker le bucket AVANT la synchronisation
        local expectedBucket = data.bucketId
        currentBucket = expectedBucket or 0
        
        if expectedBucket then
            Config.InfoPrint('Synchronisation routing bucket ' .. expectedBucket)
            Wait(3000) -- âœ… Attendre 3 secondes pour la synchronisation
            Config.SuccessPrint('DÃ©lai de synchronisation terminÃ©')
        else
            Wait(3000)
        end
        
        Wait(1000)
        
        -- RÃ©cupÃ©ration du vÃ©hicule crÃ©Ã© par le serveur
        local vehicleNetId = data.vehicleNetId
        
        if vehicleNetId then
            Config.InfoPrint('â•â•â• RÃ‰CUPÃ‰RATION VÃ‰HICULE SERVEUR â•â•â•')
            Config.DebugPrint('Vehicle Network ID reÃ§u: ' .. vehicleNetId)
            
            local maxAttempts = 100
            local attempt = 0
            
            repeat
                currentVehicle = NetworkGetEntityFromNetworkId(vehicleNetId)
                
                if currentVehicle and DoesEntityExist(currentVehicle) then
                    Config.SuccessPrint('VÃ©hicule rÃ©cupÃ©rÃ©: ' .. currentVehicle)
                    break
                end
                
                attempt = attempt + 1
                Wait(100)
                
                if attempt % 10 == 0 then
                    Config.DebugPrint('Attente vÃ©hicule... ' .. attempt .. '/100')
                end
            until attempt >= maxAttempts
            
            if not currentVehicle or not DoesEntityExist(currentVehicle) then
                error('Ã‰chec rÃ©cupÃ©ration vÃ©hicule - NetID: ' .. vehicleNetId)
            end
            
            SetVehicleOnGroundProperly(currentVehicle)
            Wait(500)
            
        else
            Config.ErrorPrint('Pas de Network ID reÃ§u - Fallback')
            
            if not LoadModel(vehicleModel) then
                error('Ã‰chec chargement modÃ¨le: ' .. vehicleModel)
            end
            
            currentVehicle = CreateVehicle(
                GetHashKey(vehicleModel),
                spawnCoords.x, spawnCoords.y, spawnCoords.z, spawnCoords.w,
                true, true
            )
            
            Wait(1500)
            
            if not DoesEntityExist(currentVehicle) then
                error('Ã‰chec crÃ©ation vÃ©hicule')
            end
            
            SetVehicleOnGroundProperly(currentVehicle)
            Wait(500)
        end
        
        -- Personnalisation du vÃ©hicule
        local primaryColor = Config.CoursePoursuit.VehicleCustomization.primaryColor
        local secondaryColor = Config.CoursePoursuit.VehicleCustomization.secondaryColor
        SetVehicleCustomPrimaryColour(currentVehicle, primaryColor.r, primaryColor.g, primaryColor.b)
        SetVehicleCustomSecondaryColour(currentVehicle, secondaryColor.r, secondaryColor.g, secondaryColor.b)
        
        local mods = Config.CoursePoursuit.VehicleCustomization.mods
        SetVehicleMod(currentVehicle, 11, mods.engine, false)
        SetVehicleMod(currentVehicle, 12, mods.brakes, false)
        SetVehicleMod(currentVehicle, 13, mods.transmission, false)
        SetVehicleMod(currentVehicle, 15, mods.suspension, false)
        ToggleVehicleMod(currentVehicle, 18, mods.turbo)
        
        SetVehicleNumberPlateText(currentVehicle, 'COURSE')
        
        pcall(function()
            SetVehicleFuelLevel(currentVehicle, 100.0)
        end)
        
        SetVehicleEngineHealth(currentVehicle, 1000.0)
        SetVehicleBodyHealth(currentVehicle, 1000.0)
        SetVehicleDoorsLocked(currentVehicle, 2)
        SetVehicleDoorsLockedForAllPlayers(currentVehicle, true)
        
        Config.SuccessPrint('VÃ©hicule personnalisÃ©')
        
        -- Placement joueur
        Config.InfoPrint('â•â•â• PLACEMENT JOUEUR â•â•â•')
        local placementSuccess = ForcePlayerIntoVehicle(ped, currentVehicle, -1)
        
        if not placementSuccess then
            error('Impossible de placer le joueur dans le vÃ©hicule')
        end
        
        SetModelAsNoLongerNeeded(GetHashKey(vehicleModel))
        
        -- Fade in
        DoScreenFadeIn(500)
        while not IsScreenFadedIn() do Wait(10) end
        
        inGame = true
        gameStartTime = GetGameTimer()
        
        Config.InfoPrint('Zone de guerre sera crÃ©Ã©e Ã  votre premiÃ¨re sortie')
        
        -- DÃ©compte 3-2-1-GO
        StartCountdown()
        
        -- Calculer fin de jeu
        if Config.CoursePoursuit.GameDuration > 0 then
            gameEndTime = GetGameTimer() + (Config.CoursePoursuit.GameDuration * 1000)
        end
        
        -- âœ… NOUVEAU: Spawner bot IMMÃ‰DIATEMENT (pas de dÃ©lai)
        if data.spawnBot then
            Config.InfoPrint('Mode solo - spawn bot immÃ©diatement')
            
            local botSpawned = SpawnBotAdversary()
            
            if not botSpawned then
                Config.ErrorPrint('Ã‰chec spawn bot - Mais le jeu continue')
            end
        end
        
        -- DÃ©marrer threads
        StartGameThreads()
        
        Config.SuccessPrint('COURSE POURSUITE V2 DÃ‰MARRÃ‰E!')
    end)
    
    if not success then
        Config.ErrorPrint('ERREUR: ' .. tostring(err))
        
        if IsScreenFadedOut() then
            DoScreenFadeIn(500)
        end
        
        if DoesEntityExist(currentVehicle) then
            DeleteEntity(currentVehicle)
            currentVehicle = nil
        end
        
        DeleteBot()
        DeleteWarZone()
        
        ShowGameNotification('âŒ Erreur: ' .. tostring(err), 5000, 'error')
        TriggerServerEvent('scharman:server:coursePoursuiteLeft', instanceId)
        
        inGame = false
        instanceId = nil
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ARRÃŠT DU JEU
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StopCoursePoursuiteGame()
    if not inGame then return end
    
    Config.InfoPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    Config.InfoPrint('ARRÃŠT DU MODE COURSE POURSUITE V2')
    Config.InfoPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    
    inGame = false
    blockExitThread = nil
    zoneCheckThread = nil
    vehicleExitThread = nil
    damageZoneThread = nil
    gameEndTime = nil
    gameStartTime = nil
    countdownActive = false
    canExitVehicle = false
    zoneCreatedOnExit = false
    currentBucket = 0
    warningMessageActive = false
    
    -- Masquer l'Ã©cran de mort
    SendNUIMessage({
        action = 'hideDeathScreen'
    })
    
    -- Supprimer la zone de guerre
    DeleteWarZone()
    
    local ped = PlayerPedId()
    
    -- âœ… NOUVEAU: Retirer l'arme donnÃ©e pendant la partie
    Config.DebugPrint('[STOP GAME] Retrait de l\'arme...')
    RemoveAllPedWeapons(ped, true)  -- Retirer TOUTES les armes
    Config.SuccessPrint('[STOP GAME] âœ… Armes retirÃ©es')
    
    -- TÃ©lÃ©portation retour
    if Config.CoursePoursuit.ReturnToNormalCoords then
        DoScreenFadeOut(500)
        Wait(500)
        
        local returnCoords = Config.CoursePoursuit.ReturnToNormalCoords
        SetEntityCoords(ped, returnCoords.x, returnCoords.y, returnCoords.z, false, false, false, true)
        SetEntityHeading(ped, returnCoords.w)
        
        -- âœ… NOUVEAU: Ressusciter le joueur
        if IsEntityDead(ped) or GetEntityHealth(ped) <= 0 then
            Config.DebugPrint('[STOP GAME] RÃ©surrection du joueur...')
            
            -- Ressusciter
            NetworkResurrectLocalPlayer(returnCoords.x, returnCoords.y, returnCoords.z, returnCoords.w, true, false)
            SetEntityHealth(ped, 200)  -- HP complet
            ClearPedTasksImmediately(ped)
            
            Config.SuccessPrint('[STOP GAME] âœ… Joueur ressuscitÃ©')
        end
        
        Wait(500)
        DoScreenFadeIn(500)
    end
    
    -- Supprimer le vÃ©hicule
    if DoesEntityExist(currentVehicle) then
        DeleteEntity(currentVehicle)
        currentVehicle = nil
        Config.DebugPrint('VÃ©hicule joueur supprimÃ©')
    end
    
    -- Supprimer le bot
    DeleteBot()
    
    instanceId = nil
    
    Config.SuccessPrint('NETTOYAGE TERMINÃ‰')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- THREADS DE GESTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartBlockExitThread()
    if blockExitThread then return end
    
    Config.DebugPrint('Thread blocage sortie dÃ©marrÃ©')
    
    -- Timer 30 secondes
    CreateThread(function()
        -- Afficher le message de blocage
        SendNUIMessage({
            action = 'showVehicleLock',
            data = { duration = 30000 }
        })
        
        Wait(30000)
        
        canExitVehicle = true
        
        -- Masquer le message
        SendNUIMessage({
            action = 'hideVehicleLock'
        })
        
        Config.SuccessPrint('âœ… Vous pouvez maintenant sortir du vÃ©hicule!')
        ShowGameNotification('âœ… Vous pouvez maintenant sortir du vÃ©hicule!', 5000, 'success')
    end)
    
    blockExitThread = CreateThread(function()
        local wasInVehicle = true
        
        while inGame and Config.CoursePoursuit.BlockExitVehicle do
            Wait(0)
            
            local ped = PlayerPedId()
            local isInVehicle = IsPedInVehicle(ped, currentVehicle, false)
            
            if not canExitVehicle then
                DisableControlAction(0, 75, true)
                
                if IsDisabledControlJustPressed(0, 75) then
                    local timeElapsed = (GetGameTimer() - gameStartTime) / 1000
                    local timeLeft = math.max(0, 30 - timeElapsed)
                    ShowGameNotification(string.format('â° Attendez encore %d secondes!', math.ceil(timeLeft)), 3000, 'warning')
                end
                
                if DoesEntityExist(currentVehicle) and not isInVehicle then
                    ForcePlayerIntoVehicle(ped, currentVehicle, -1)
                    ShowGameNotification('ğŸš— Retour forcÃ© - Attendez 30s', 3000, 'warning')
                end
            end
            
            wasInVehicle = isInVehicle
        end
        
        blockExitThread = nil
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… THREAD DÃ‰GÃ‚TS ZONE DE GUERRE (AMÃ‰LIORÃ‰)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function StartDamageZoneThread()
    if damageZoneThread then
        Config.DebugPrint('[DAMAGE ZONE] Thread dÃ©jÃ  actif, ignorÃ©')
        return
    end
    
    Config.InfoPrint('[DAMAGE ZONE] ğŸ”´ DÃ‰MARRAGE THREAD DÃ‰GÃ‚TS')
    Config.DebugPrint('[DAMAGE ZONE] Ã‰tat initial:')
    Config.DebugPrint('[DAMAGE ZONE] - inGame: ' .. tostring(inGame))
    Config.DebugPrint('[DAMAGE ZONE] - warZoneActive: ' .. tostring(warZoneActive))
    Config.DebugPrint('[DAMAGE ZONE] - zoneCreatedOnExit: ' .. tostring(zoneCreatedOnExit))
    Config.DebugPrint('[DAMAGE ZONE] - warZonePosition: ' .. tostring(warZonePosition))
    
    damageZoneThread = CreateThread(function()
        local cycleCount = 0
        
        while inGame and warZoneActive do
            Wait(1000) -- VÃ©rifier toutes les 1 seconde
            cycleCount = cycleCount + 1
            
            -- âœ… LOG: Cycle du thread
            if cycleCount % 5 == 0 then
                Config.DebugPrint('[DAMAGE ZONE] Thread actif - Cycle: ' .. cycleCount)
            end
            
            -- Attendre que la zone soit crÃ©Ã©e
            if not warZonePosition or not zoneCreatedOnExit then
                if cycleCount == 1 then
                    Config.DebugPrint('[DAMAGE ZONE] â³ Attente crÃ©ation zone...')
                end
                goto continue
            end
            
            if cycleCount == 1 then
                Config.SuccessPrint('[DAMAGE ZONE] âœ… Zone dÃ©tectÃ©e, dÃ©but surveillance')
            end
            
            local ped = PlayerPedId()
            
            -- âœ… VÃ©rifier si le joueur est mort
            local isDead = IsEntityDead(ped)
            local health = GetEntityHealth(ped)
            
            if isDead or health <= 0 then
                Config.InfoPrint('[DAMAGE ZONE] ğŸ’€ JOUEUR MORT DÃ‰TECTÃ‰')
                Config.DebugPrint('[DAMAGE ZONE] - Health: ' .. health)
                
                -- Afficher Ã©cran de mort
                SendNUIMessage({
                    action = 'showDeathScreen'
                })
                
                Wait(3000) -- Attendre 3 secondes
                
                -- Terminer la partie
                StopCoursePoursuiteGame()
                TriggerServerEvent('scharman:server:coursePoursuiteLeft', instanceId)
                ShowGameNotification('ğŸ’€ Vous Ãªtes mort ! Retour au PED...', 3000, 'error')
                
                break
            end
            
            local playerCoords = GetEntityCoords(ped)
            local distance = #(playerCoords - vector3(warZonePosition.x, warZonePosition.y, warZonePosition.z))
            
            Config.DebugPrint('[DAMAGE ZONE] Distance zone: ' .. string.format("%.1f", distance) .. 'm / ' .. warZoneRadius .. 'm')
            
            -- âœ… Si hors de la zone de guerre
            if distance > warZoneRadius then
                local currentHealth = GetEntityHealth(ped)
                local newHealth = currentHealth - 20
                
                Config.InfoPrint('[DAMAGE ZONE] âš¡ JOUEUR HORS ZONE!')
                Config.InfoPrint('[DAMAGE ZONE] - Distance: ' .. string.format("%.1f", distance) .. 'm')
                Config.InfoPrint('[DAMAGE ZONE] - HP: ' .. currentHealth .. ' â†’ ' .. newHealth)
                
                -- âœ… Message d'avertissement persistant
                if not warningMessageActive then
                    warningMessageActive = true
                    Config.DebugPrint('[DAMAGE ZONE] DÃ©marrage thread avertissement')
                    
                    CreateThread(function()
                        local warningCount = 0
                        while inGame and distance > warZoneRadius do
                            warningCount = warningCount + 1
                            ShowGameNotification('âš ï¸ HORS ZONE! Revenez ou vous allez mourir!', 1500, 'warning')
                            Config.DebugPrint('[DAMAGE ZONE] Avertissement #' .. warningCount)
                            Wait(2000)
                            
                            -- Recalculer la distance
                            local newCoords = GetEntityCoords(PlayerPedId())
                            distance = #(newCoords - vector3(warZonePosition.x, warZonePosition.y, warZonePosition.z))
                            Config.DebugPrint('[DAMAGE ZONE] Nouvelle distance: ' .. string.format("%.1f", distance) .. 'm')
                        end
                        
                        warningMessageActive = false
                        Config.SuccessPrint('[DAMAGE ZONE] âœ… Fin avertissements')
                        ShowGameNotification('âœ… Retour dans la zone!', 2000, 'success')
                    end)
                end
                
                -- Infliger dÃ©gÃ¢ts
                SetEntityHealth(ped, math.max(0, newHealth))
                Config.SuccessPrint('[DAMAGE ZONE] DÃ©gÃ¢ts infligÃ©s: -20 HP')
                
                -- âœ… DÃ‰SACTIVÃ‰: Ragdoll fait tomber le joueur
                -- SetPedToRagdoll(ped, 500, 500, 0, 0, 0, 0)
                
                -- Notification de dÃ©gÃ¢ts
                ShowGameNotification('âš¡ DÃ‰GÃ‚TS ZONE: -20 HP', 1500, 'error')
                
                -- âœ… VÃ©rifier si mort aprÃ¨s dÃ©gÃ¢ts
                if newHealth <= 0 then
                    Config.InfoPrint('[DAMAGE ZONE] ğŸ’€ JOUEUR TUÃ‰ PAR LA ZONE')
                    -- Le thread dÃ©tectera la mort au prochain cycle
                end
            else
                -- Dans la zone - rÃ©initialiser le flag d'avertissement
                if warningMessageActive then
                    Config.DebugPrint('[DAMAGE ZONE] Joueur revenu dans zone, stop avertissements')
                end
                warningMessageActive = false
            end
            
            ::continue::
        end
        
        damageZoneThread = nil
        Config.InfoPrint('[DAMAGE ZONE] ğŸ”´ ARRÃŠT THREAD DÃ‰GÃ‚TS')
        Config.DebugPrint('[DAMAGE ZONE] - Raison: inGame=' .. tostring(inGame) .. ', warZoneActive=' .. tostring(warZoneActive))
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- THREAD VÃ‰RIFICATION ZONE (TÃ©lÃ©portation)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartZoneCheckThread()
    if not Config.CoursePoursuit.UseZoneLimit then return end
    if zoneCheckThread then return end
    
    Config.DebugPrint('Thread vÃ©rification zone dÃ©marrÃ©')
    
    zoneCheckThread = CreateThread(function()
        local timeOutOfZone = 0
        
        while inGame do
            Wait(1000)
            
            local ped = PlayerPedId()
            local playerCoords = GetEntityCoords(ped)
            local zoneCenter = Config.CoursePoursuit.SpawnCoords
            local distance = #(playerCoords - vector3(zoneCenter.x, zoneCenter.y, zoneCenter.z))
            
            if distance > Config.CoursePoursuit.ZoneRadius then
                timeOutOfZone = timeOutOfZone + 1
                
                if timeOutOfZone == 1 then
                    ShowGameNotification('âš ï¸ Retournez dans la zone!', 3000, 'warning')
                end
                
                if timeOutOfZone >= Config.CoursePoursuit.OutOfZoneTimeout then
                    ShowGameNotification('ğŸš« Trop loin - TÃ©lÃ©portation...', 3000, 'error')
                    SetEntityCoords(ped, zoneCenter.x, zoneCenter.y, zoneCenter.z, false, false, false, true)
                    timeOutOfZone = 0
                end
            else
                timeOutOfZone = 0
            end
        end
        
        zoneCheckThread = nil
    end)
end

local function StartGameTimerThread()
    if Config.CoursePoursuit.GameDuration <= 0 then return end
    
    CreateThread(function()
        while inGame and gameEndTime do
            Wait(1000)
            
            if not gameEndTime then break end
            
            local timeLeft = gameEndTime - GetGameTimer()
            
            if timeLeft <= 0 then
                ShowGameNotification('â±ï¸ Temps Ã©coulÃ©!', 5000, 'info')
                StopCoursePoursuiteGame()
                TriggerServerEvent('scharman:server:coursePoursuiteLeft', instanceId)
                break
            end
        end
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DÃ‰TECTION SORTIE VÃ‰HICULE (Pour crÃ©er la zone)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartVehicleExitDetectionThread()
    if vehicleExitThread then return end
    
    vehicleExitThread = CreateThread(function()
        Config.DebugPrint('Thread dÃ©tection sortie vÃ©hicule dÃ©marrÃ©')
        
        while inGame and not zoneCreatedOnExit do
            Wait(500)
            
            local ped = PlayerPedId()
            
            -- Si le joueur peut sortir ET n'est PAS dans un vÃ©hicule
            if canExitVehicle and not IsPedInAnyVehicle(ped, false) then
                -- CrÃ©er la zone de guerre Ã  la position actuelle
                local coords = GetEntityCoords(ped)
                CreateWarZone(coords)
                ShowGameNotification('ğŸ”´ ZONE DE GUERRE crÃ©Ã©e Ã  votre position !', 5000, 'warning')
                
                -- Donner l'arme CAL50
                local weaponHash = GetHashKey('WEAPON_PISTOL50')
                GiveWeaponToPed(ped, weaponHash, 250, false, true)
                SetCurrentPedWeapon(ped, weaponHash, true)
                Config.SuccessPrint('Arme donnÃ©e: Pistolet Cal .50')
                ShowGameNotification('ğŸ”« Pistolet Cal .50 Ã©quipÃ© !', 3000, 'success')
                
                Config.SuccessPrint('Zone de guerre crÃ©Ã©e Ã  la sortie du vÃ©hicule')
                break
            end
        end
        
        vehicleExitThread = nil
        Config.DebugPrint('Thread dÃ©tection sortie vÃ©hicule arrÃªtÃ©')
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DÃ‰MARRAGE DES THREADS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function StartGameThreads()
    Config.DebugPrint('[GAME THREADS] DÃ©marrage threads de jeu')
    StartBlockExitThread()
    StartZoneCheckThread()
    StartGameTimerThread()
    StartVehicleExitDetectionThread()
    -- âœ… CORRECTION: Ne PAS dÃ©marrer damageZoneThread ici
    -- Il sera dÃ©marrÃ© dans CreateWarZone() quand la zone est crÃ©Ã©e
    Config.DebugPrint('[GAME THREADS] Threads lancÃ©s (sauf dÃ©gÃ¢ts zone)')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ã‰VÃ‰NEMENTS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RegisterNetEvent('scharman:client:startCoursePoursuit', function(data)
    StartCoursePoursuiteGame(data)
end)

RegisterNetEvent('scharman:client:stopCoursePoursuit', function()
    StopCoursePoursuiteGame()
end)

RegisterNetEvent('scharman:client:courseNotification', function(message, duration, notifType)
    ShowGameNotification(message, duration or 3000, notifType or 'info')
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- COMMANDES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RegisterCommand('quit_course', function()
    if inGame then
        StopCoursePoursuiteGame()
        TriggerServerEvent('scharman:server:coursePoursuiteLeft', instanceId)
        ShowGameNotification('âœ… Vous avez quittÃ©', 3000, 'success')
    else
        ShowGameNotification('âŒ Vous n\'Ãªtes pas en partie', 3000, 'error')
    end
end, false)

if Config.Debug then
    RegisterCommand('course_stop', function()
        if inGame then
            StopCoursePoursuiteGame()
            TriggerServerEvent('scharman:server:coursePoursuiteLeft', instanceId)
        end
    end, false)
    
    RegisterCommand('course_info', function()
        print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
        print('Ã‰tat: ' .. (inGame and 'EN JEU' or 'PAS EN JEU'))
        print('Instance: ' .. (instanceId or 'Aucune'))
        print('VÃ©hicule: ' .. (currentVehicle or 'Aucun'))
        print('Bucket: ' .. currentBucket)
        print('Zone de guerre: ' .. (warZoneActive and 'ACTIVE' or 'INACTIVE'))
        print('Zone crÃ©Ã©e: ' .. (zoneCreatedOnExit and 'OUI' or 'NON'))
        print('Peut sortir vÃ©hicule: ' .. (canExitVehicle and 'OUI' or 'NON'))
        print('Bot PED: ' .. (botPed or 'Aucun'))
        print('Bot Vehicle: ' .. (botVehicle or 'Aucun'))
        print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    end, false)
end

Config.DebugPrint('client/course_poursuite.lua V2 CORRIGÃ‰ chargÃ©')
